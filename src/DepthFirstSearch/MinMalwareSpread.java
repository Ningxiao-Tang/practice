package DepthFirstSearch;

import java.util.*;

public class MinMalwareSpread {
    //bfs
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Map<Integer, Integer> countMap = new HashMap<>();
        Set<Integer> set = new HashSet<>();
        for (int v:initial)
            set.add(v);

        for (int v : initial){
            if (!countMap.containsKey(v)){
                countMap.putAll(calcImpacted(graph,v, set));
            }
        }

        int maxCount = -1, ret = 0;
        for (Map.Entry<Integer, Integer> entry: countMap.entrySet()) {
            if (!set.contains(entry.getKey())) continue;
            if (entry.getValue() > maxCount) {
                ret = entry.getKey();
                maxCount = entry.getValue();
            } else if (entry.getValue() == maxCount && entry.getKey() < ret){
                ret = entry.getKey();
            }
        }
        return ret;
    }

    private Map<Integer,Integer> calcImpacted(int[][] graph, int initial, Set<Integer> initialSet) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(initial);
        Set<Integer> set =  new HashSet<>();
        boolean dup = false;
        while(q.size() > 0) {
            int v = q.poll();
            set.add(v);
            for (int j = 0; j < graph.length; j++) {
                if (graph[v][j] == 1 && ! set.contains(j)){
                    q.offer(j);
                    if(j != initial && initialSet.contains(j)) {
                        dup = true;
                    }
                }

            }
        }
        Map<Integer, Integer> countMap = new HashMap<>();
        for (int v : set) {
            int count = dup ? 0 : set.size();
            countMap.put(v, count);
        }
        return countMap;
    }
    //union find
    private int[] p;

    public int solution(int[][] g, int[] initial) {
        int n = g.length;
        p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);
        int[] ufSize = new int[n];
        int[] malCount = new int[n];
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        for (int init : initial) malCount[find(init)]++;
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }

    private void union(int i, int j) {
        p[find(i)] = find(j);
    }

    private int find(int i) {
        if (p[i] == i) return i;
        else {
            p[i] = find(p[i]);
            return p[i];
        }
    }
}
