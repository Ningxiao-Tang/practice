package DepthFirstSearch;

import java.util.*;

public class MinMalwareSpread {
    //bfs
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Map<Integer, Integer> countMap = new HashMap<>();
        Set<Integer> set = new HashSet<>();
        for (int v:initial)
            set.add(v);

        for (int v : initial){
            if (!countMap.containsKey(v)){
                countMap.putAll(calcImpacted(graph,v, set));
            }
        }

        int maxCount = -1, ret = 0;
        for (Map.Entry<Integer, Integer> entry: countMap.entrySet()) {
            if (!set.contains(entry.getKey())) continue;
            if (entry.getValue() > maxCount) {
                ret = entry.getKey();
                maxCount = entry.getValue();
            } else if (entry.getValue() == maxCount && entry.getKey() < ret){
                ret = entry.getKey();
            }
        }
        return ret;
    }

    private Map<Integer,Integer> calcImpacted(int[][] graph, int initial, Set<Integer> initialSet) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(initial);
        Set<Integer> set =  new HashSet<>();
        boolean dup = false;
        while(q.size() > 0) {
            int v = q.poll();
            set.add(v);
            for (int j = 0; j < graph.length; j++) {
                if (graph[v][j] == 1 && ! set.contains(j)){
                    q.offer(j);
                    if(j != initial && initialSet.contains(j)) {
                        dup = true;
                    }
                }

            }
        }
        Map<Integer, Integer> countMap = new HashMap<>();
        for (int v : set) {
            int count = dup ? 0 : set.size();
            countMap.put(v, count);
        }
        return countMap;
    }
    //union find
    private int[] p;

    public int solution(int[][] g, int[] initial) {
        int n = g.length;
        p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);
        int[] ufSize = new int[n];
        int[] malCount = new int[n];
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        for (int init : initial) malCount[find(init)]++;
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }

    private void union(int i, int j) {
        p[find(i)] = find(j);
    }

    private int find(int i) {
        if (p[i] == i) return i;
        else {
            p[i] = find(p[i]);
            return p[i];
        }
    }

    public int minMalwareSpread2(int[][] graph, int[] initial) {
        int N = graph.length;
        int[] clean = new int[N];
        Arrays.fill(clean, 1);
        for (int x : initial)
            clean[x] = 0;

        ArrayList<Integer> [] infectedBy = new ArrayList[N];
        for (int i = 0; i < N; i++) {
            infectedBy[i] = new ArrayList();
        }

        //for each node in initial, dfs to find all nodes that it can reach
        for (int u : initial) {
            Set<Integer> seen = new HashSet<>();
            dfs(graph, clean, u, seen);
            for (int v : seen){
                infectedBy[v].add(u);
            }
        }

        int[] contribution = new int[N];
        for (int v = 0; v < N; v++){
            if (infectedBy[v].size() == 1)
                contribution[infectedBy[v].get(0)]++;
        }
        //find the best answer
        Arrays.sort(initial);
        int ans = initial[0], ansSize = -1;
        for (int u: initial){
            int score = contribution[u];
            if (score > ansSize || score == ansSize && u < ans){
                ans = u;
                ansSize = score;
            }
        }
        return ans;
    }

    private void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {
        for (int v = 0; v < graph.length; ++v) {
            if (graph[u][v] == 1 && clean[v] == 1  && !seen.contains(v)){
                seen.add(v);
                dfs(graph, clean, v, seen);
            }
        }
    }

}
